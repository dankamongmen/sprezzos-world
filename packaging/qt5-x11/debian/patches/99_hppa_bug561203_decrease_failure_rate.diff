Description: decrease failure rate of QProcess (#561203) on hppa ~100+ times
 The patch adds a usleep() of 1000 before fork() in QProcess on hppa. This hack
 seems to bring down likelihood of failure caused by #561203 from ~ 1/6 to
~1/1000 when run in a row. Hopefully, this will make failures rare enough
 not to cause FTBFSes.
 Degradation in performance should not be very significant and is acceptable.
Author: Modestas Vainius <modax@debian.org>
Author: Fathi Boudra <fabo@debian.org>
Forwarded: not-needed
Bug-Debian: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=561203
Origin: vendor
Last-Update: 2011-12-26

---
 src/corelib/io/qprocess_unix.cpp |   10 ++++++++++
 1 file changed, 10 insertions(+)

--- a/src/corelib/io/qprocess_unix.cpp
+++ b/src/corelib/io/qprocess_unix.cpp
@@ -526,6 +526,13 @@ static char **_q_dupEnvironment(const QP
     return envp;
 }
 
+inline void debbug_561203()
+{
+#if defined(__linux__) && defined(__hppa__)
+        usleep(1000);
+#endif
+}
+
 #ifdef Q_OS_MAC
 Q_GLOBAL_STATIC(QMutex, cfbundleMutex);
 #endif
@@ -647,6 +654,7 @@ void QProcessPrivate::startProcess()
 #if defined(Q_OS_QNX)
     pid_t childPid = spawnChild(workingDirPtr, argv, envp);
 #else
+    debbug_561203();
     pid_t childPid = fork();
     int lastForkErrno = errno;
 #endif
@@ -1340,6 +1348,7 @@ bool QProcessPrivate::startDetached(cons
     int pidPipe[2];
     qt_safe_pipe(pidPipe);
 
+    debbug_561203();
     pid_t childPid = fork();
     if (childPid == 0) {
         struct sigaction noaction;
@@ -1352,6 +1361,7 @@ bool QProcessPrivate::startDetached(cons
         qt_safe_close(startedPipe[0]);
         qt_safe_close(pidPipe[0]);
 
+        debbug_561203();
         pid_t doubleForkPid = fork();
         if (doubleForkPid == 0) {
             qt_safe_close(pidPipe[1]);
