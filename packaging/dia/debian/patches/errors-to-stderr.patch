Description: Direct messages and errors to stdout
 This patch directs messages and errors to stdout to enable
 piping calls of dia, e.g. "dia -e /dev/stdout ... | ..."
 by preventing other messages on stdout
Author: Roland Stigge <stigge@antcom.de>
Bug-Debian: http://bugs.debian.org/328904
Bug: http://bugzilla.gnome.org/show_bug.cgi?id=113909

--- dia-0.97.2.orig/lib/neworth_conn.c
+++ dia-0.97.2/lib/neworth_conn.c
@@ -341,14 +341,14 @@ neworthconn_update_data(NewOrthConn *ort
     if (connpoint_is_autogap(start_cp)) {
       new_points[0] = calculate_object_edge(&start_cp->pos, &new_points[1],
 					    start_cp->object);
-      printf("Moved start to %f, %f\n",
+      fprintf(stderr, "Moved start to %f, %f\n",
 	     new_points[0].x, new_points[0].y);
     }
     if (connpoint_is_autogap(end_cp)) {
       new_points[orth->numpoints-1] =
 	calculate_object_edge(&end_cp->pos, &new_points[orth->numpoints-2],
 			      end_cp->object);
-      printf("Moved end to %f, %f\n",
+      fprintf(stderr, "Moved end to %f, %f\n",
 	     new_points[orth->numpoints-1].x, new_points[orth->numpoints-1].y);
     }
     g_free(points);
--- dia-0.97.2.orig/lib/widgets.c
+++ dia-0.97.2/lib/widgets.c
@@ -1174,7 +1174,7 @@ dia_color_selector_set_color (GtkWidget
   green = color->green * 255;
   blue = color->blue * 255;
   if (color->red > 1.0 || color->green > 1.0 || color->blue > 1.0) {
-    printf("Color out of range: r %f, g %f, b %f\n",
+    fprintf(stderr, "Color out of range: r %f, g %f, b %f\n",
 	   color->red, color->green, color->blue);
     red = MIN(red, 255);
     green = MIN(green, 255);
--- dia-0.97.2.orig/lib/dia_xml.c
+++ dia-0.97.2/lib/dia_xml.c
@@ -239,7 +239,7 @@ xmlDiaParseFile(const char *filename)
       /* We've got a corrected file to parse. */
       xmlDocPtr ret = xmlDoParseFile(fname);
       unlink(fname);
-      /* printf("has read %s instead of %s\n",fname,filename); */
+      /* fprintf(stderr, "has read %s instead of %s\n",fname,filename); */
       g_free((void *)fname);
       return ret;
     } else {
--- dia-0.97.2.orig/lib/geometry.c
+++ dia-0.97.2/lib/geometry.c
@@ -772,9 +772,9 @@ calculate_object_edge(Point *objmid, Poi
 #ifdef TRACE_DIST
   if (i == MAXITER) {
     for (i = 0; i < MAXITER; i++) {
-      printf("%d: %f, %f: %f\n", i, trace[i].x, trace[i].y, disttrace[i]);
+      fprintf(stderr, "%d: %f, %f: %f\n", i, trace[i].x, trace[i].y, disttrace[i]);
     }
-    printf("i = %d, dist = %f\n", i, dist);
+    fprintf(stderr, "i = %d, dist = %f\n", i, dist);
   }
 #endif
 
--- dia-0.97.2.orig/lib/arrows.c
+++ dia-0.97.2/lib/arrows.c
@@ -2134,7 +2134,7 @@ arrow_type_from_name(const gchar *name)
       return arrow_types[i].enum_value;
     }
   }
-  printf("Unknown arrow type %s\n", name);
+  fprintf(stderr, "Unknown arrow type %s\n", name);
   return 0;
 }
 
@@ -2153,7 +2153,7 @@ arrow_index_from_type(ArrowType atype)
       return i;
     }
   }
-  printf("Can't find arrow index for type %d\n", atype);
+  fprintf(stderr, "Can't find arrow index for type %d\n", atype);
   return 0;
 }
 
--- dia-0.97.2.orig/lib/dia_svg.c
+++ dia-0.97.2/lib/dia_svg.c
@@ -576,7 +576,7 @@ dia_svg_parse_path(const gchar *path_str
   path_chomp(path);
   while (path[0] != '\0') {
 #ifdef DEBUG_CUSTOM
-    g_print("Path: %s\n", path);
+    g_printerr("Path: %s\n", path);
 #endif
     /* check for a new command */
     switch (path[0]) {
--- dia-0.97.2.orig/lib/dialib.c
+++ dia-0.97.2/lib/dialib.c
@@ -69,7 +69,7 @@ myXmlErrorReporting (void *ctx, const ch
 
   va_start(args, msg);
   string = g_strdup_vprintf (msg, args);
-  g_print ("%s", string ? string : "xml error (null)?");
+  g_print("%s", string ? string : "xml error (null)?");
   va_end(args);
 
   g_free(string);
--- dia-0.97.2.orig/lib/debug.c
+++ dia-0.97.2/lib/debug.c
@@ -36,7 +36,7 @@ dia_assert_true(gboolean val, gchar *for
   va_list args;
   if (!val) {
     va_start(args, format);
-    g_vprintf(format, args);
+    g_vfprintf(stderr, format, args);
     va_end(args);
   }
   return val;
--- dia-0.97.2.orig/lib/autoroute.c
+++ dia-0.97.2/lib/autoroute.c
@@ -105,7 +105,7 @@ autoroute_layout_orthconn(OrthConn *conn
 	endpoint = autolayout_adjust_for_gap(&topos, enddir, endconn);
 	autolayout_adjust_for_arrow(&endpoint, enddir, conn->extra_spacing.end_trans);
 	/*
-	printf("Startdir %d enddir %d orgstart %.2f, %.2f orgend %.2f, %.2f start %.2f, %.2f end %.2f, %.2f\n",
+	fprintf(stderr, "Startdir %d enddir %d orgstart %.2f, %.2f orgend %.2f, %.2f start %.2f, %.2f end %.2f, %.2f\n",
 	       startdir, enddir,
 	       frompos.x, frompos.y,
 	       topos.x, topos.y,
@@ -132,7 +132,7 @@ autoroute_layout_orthconn(OrthConn *conn
 	if (this_layout != NULL) {
 	  if (this_badness-min_badness < -0.00001) {
 	    /*
-	    printf("Dir %d to %d badness %f < %f\n", startdir, enddir,
+	    fprintf(stderr, "Dir %d to %d badness %f < %f\n", startdir, enddir,
 		   this_badness, min_badness);
 	    */
 	    min_badness = this_badness;
@@ -286,7 +286,7 @@ autoroute_layout_parallel(Point *to, gui
   if (fabs(to->x) > MIN_DIST) {
     real top = MIN(-MIN_DIST, to->y-MIN_DIST);
     /*
-    printf("Doing parallel layout: Wide\n");
+    fprintf(stderr, "Doing parallel layout: Wide\n");
     */
     *num_points = 4;
     ps = g_new0(Point, *num_points);
@@ -300,7 +300,7 @@ autoroute_layout_parallel(Point *to, gui
     real off = to->x+MIN_DIST*(to->x>0?1.0:-1.0);
     real bottom = to->y-MIN_DIST;
     /*
-    printf("Doing parallel layout: Narrow\n");
+    fprintf(stderr, "Doing parallel layout: Narrow\n");
     */
     *num_points = 6;
     ps = g_new0(Point, *num_points);
@@ -318,7 +318,7 @@ autoroute_layout_parallel(Point *to, gui
     real off = MIN_DIST*(to->x>0?-1.0:1.0);
     real bottom = -MIN_DIST;
     /*
-    printf("Doing parallel layout: Narrow\n");
+    fprintf(stderr, "Doing parallel layout: Narrow\n");
     */
     *num_points = 6;
     ps = g_new0(Point, *num_points);
@@ -356,7 +356,7 @@ autoroute_layout_orthogonal(Point *to, i
   if (to->y < -MIN_DIST) {
     if (dirmult*to->x > MIN_DIST) {
       /*
-      printf("Doing orthogonal layout: Three-way\n");
+      fprintf(stderr, "Doing orthogonal layout: Three-way\n");
       */
       *num_points = 3;
       ps = g_new0(Point, *num_points);
@@ -402,7 +402,7 @@ autoroute_layout_orthogonal(Point *to, i
     }
   }
   /*
-  printf("Doing orthogonal layout\n");
+  fprintf(stderr, "Doing orthogonal layout\n");
   */
   *points = ps;
   return calculate_badness(ps, *num_points);
@@ -431,7 +431,7 @@ autoroute_layout_opposite(Point *to, gui
     } else {
       real mid = to->y/2;
       /*
-	printf("Doing opposite layout: Three-way\n");
+	fprintf(stderr, "Doing opposite layout: Three-way\n");
       */
       /* points[0] is 0,0 */
       ps[1].y = mid;
@@ -444,7 +444,7 @@ autoroute_layout_opposite(Point *to, gui
   } else if (fabs(to->x) > 2*MIN_DIST) {
     real mid = to->x/2;
     /*
-    printf("Doing opposite layout: Doorhanger\n");
+    fprintf(stderr, "Doing opposite layout: Doorhanger\n");
     */
     *num_points = 6;
     ps = g_new0(Point, *num_points);
@@ -460,7 +460,7 @@ autoroute_layout_opposite(Point *to, gui
   } else {
     real off = MIN_DIST*(to->x>0?-1.0:1.0);
     /*
-    printf("Doing opposite layout: Overlap\n");
+    fprintf(stderr, "Doing opposite layout: Overlap\n");
     */
     *num_points = 6;
     ps = g_new0(Point, *num_points);
--- dia-0.97.2.orig/lib/orth_conn.c
+++ dia-0.97.2/lib/orth_conn.c
@@ -334,7 +334,7 @@ orthconn_update_data(OrthConn *orth)
       new_points[0] = calculate_object_edge(&start_cp->pos, &new_points[1],
 					    start_cp->object);
       /*
-      printf("Moved start to %f, %f\n",
+      fprintf(stderr, "Moved start to %f, %f\n",
 	     new_points[0].x, new_points[0].y);
       */
     }
@@ -343,7 +343,7 @@ orthconn_update_data(OrthConn *orth)
 	calculate_object_edge(&end_cp->pos, &new_points[orth->numpoints-2],
 			      end_cp->object);
       /*
-      printf("Moved end to %f, %f\n",
+      fprintf(stderr, "Moved end to %f, %f\n",
 	     new_points[orth->numpoints-1].x, new_points[orth->numpoints-1].y);
       */
     }
--- dia-0.97.2.orig/lib/diarenderer.c
+++ dia-0.97.2/lib/diarenderer.c
@@ -1257,7 +1257,7 @@ draw_arc_with_arrows (DiaRenderer *rende
 
   if (!find_center_point(&center, startpoint, endpoint, midpoint)) {
     /* Degenerate circle -- should have been caught by the drawer? */
-    printf("Degenerate\n");
+    fprintf(stderr, "Degenerate\n");
   }
 
   righthand = is_right_hand (startpoint, midpoint, endpoint);
--- dia-0.97.2.orig/lib/textline.c
+++ dia-0.97.2/lib/textline.c
@@ -283,7 +283,7 @@ text_line_adjust_glyphs(TextLine *line,
 
   for (i = 0; i < glyphs->num_glyphs; i++) {
 /*
-    printf("Glyph %d: width %d, offset %f, textwidth %f\n",
+    fprintf(stderr, "Glyph %d: width %d, offset %f, textwidth %f\n",
 	   i, new_glyphs->glyphs[i].geometry.width, line->offsets[i],
 	   line->offsets[i] * scale * 20.0 * PANGO_SCALE);
 */
@@ -314,7 +314,7 @@ text_line_adjust_layout_line(TextLine *l
   runs = line->layout_offsets->runs;
 
   if (g_slist_length(runs) != g_slist_length(layoutruns)) {
-    printf("Runs length error: %d != %d\n",
+    fprintf(stderr, "Runs length error: %d != %d\n",
 	   g_slist_length(line->layout_offsets->runs),
 	   g_slist_length(layoutline->runs));
   }
@@ -334,7 +334,7 @@ text_line_adjust_layout_line(TextLine *l
 	(int)(glyphs->glyphs[i].geometry.y_offset * scale / 20.0);
     }
     if (glyphs->num_glyphs != layoutglyphs->num_glyphs) {
-      printf("Glyph length error: %d != %d\n", 
+      fprintf(stderr, "Glyph length error: %d != %d\n", 
 	     glyphs->num_glyphs, layoutglyphs->num_glyphs);
     }
   }
--- dia-0.97.2.orig/plug-ins/python/pydia-error.c
+++ dia-0.97.2/plug-ins/python/pydia-error.c
@@ -127,7 +127,7 @@ PyDiaError_Write(PyDiaError *self, PyObj
   if (self->str)
     g_string_append (self->str, s);
 
-  g_print ("%s", s);
+  g_printerr("%s", s);
 
   Py_INCREF(Py_None);
   return Py_None;
--- dia-0.97.2.orig/plug-ins/python/pydia-properties.c
+++ dia-0.97.2/plug-ins/python/pydia-properties.c
@@ -228,7 +228,7 @@ PyDiaProperties_AssSub (PyDiaProperties*
     name = PyString_AsString(key);
     p = object_prop_by_name (self->object, name);  
 
-    /* g_print ("AssSub(key: '%s', type <%s>)\n", name, (p ? p->type : "none")); */
+    /* g_printerr("AssSub(key: '%s', type <%s>)\n", name, (p ? p->type : "none")); */
     if (p) {
       if (0 == PyDiaProperty_ApplyToObject(self->object, name, p, val)) {
         /* if applied the property is deleted */
--- dia-0.97.2.orig/plug-ins/xslt/xslt.c
+++ dia-0.97.2/plug-ins/xslt/xslt.c
@@ -291,14 +291,14 @@ static PluginInitResult read_configurati
     
     /*cur_from = froms;
 
-    printf("XSLT plugin configuration: \n");
+    fprintf(stderr, "XSLT plugin configuration: \n");
     while(cur_from != NULL)
     {
-	printf("From: %s (%s)\n", cur_from->name, cur_from->xsl);
+	fprintf(stderr, "From: %s (%s)\n", cur_from->name, cur_from->xsl);
 	
 	cur_to = cur_from->xsls;
 	while(cur_to != NULL) {
-	    printf("\tTo: %s (%s)\n", cur_to->name, cur_to->xsl);
+	    fprintf(stderr, "\tTo: %s (%s)\n", cur_to->name, cur_to->xsl);
 	    cur_to = cur_to->next;
 	}
 	cur_from = cur_from->next;
@@ -374,7 +374,7 @@ void xslt_unload(PluginInfo *info)
 #if 0
 	language_t *cur = languages, *next;
 	
-      /*printf("Unloading xslt\n"); */
+      /*fprintf(stderr, "Unloading xslt\n"); */
 
 	while(cur != NULL) {
 		next = cur->next;
--- dia-0.97.2.orig/plug-ins/xslt/xsltdialog.c
+++ dia-0.97.2/plug-ins/xslt/xsltdialog.c
@@ -71,7 +71,7 @@ from_deactivate(fromxsl_t *xsls)
 static void
 to_update(GtkWidget *widget, toxsl_t *lng)
 {
-        /* printf("To: %s\n", lng->name); */
+        /* fprintf(stderr, "To: %s\n", lng->name); */
 	xsl_to = lng;
 }
 
--- dia-0.97.2.orig/plug-ins/wpg/wpg.c
+++ dia-0.97.2/plug-ins/wpg/wpg.c
@@ -298,7 +298,7 @@ begin_render(DiaRenderer *self)
     pPal[3*i+1] = (((i / CC_LEN) % CC_LEN) * 255) / (CC_LEN - 1); /* green */
     pPal[3*i+2] = ((i / (CC_LEN * CC_LEN)) * 255) / (CC_LEN - 1); /* blue varies least */
     /*
-    g_print("%d\t%d\t%d\n", pPal[3*i  ], pPal[3*i+1], pPal[3*i+2]);
+    g_printerr("%d\t%d\t%d\n", pPal[3*i  ], pPal[3*i+1], pPal[3*i+2]);
      */
   } 
 
@@ -1208,7 +1208,7 @@ import_data (const gchar *filename, Diag
         else {
           bRet = (1 == fread(&i16, sizeof(guint16), 1, f));
           if (0x8000 & i16) {
-            DIAG_NOTE(g_print("Large Object: hi:lo %04X", (int)i16));
+            DIAG_NOTE(g_printerr("Large Object: hi:lo %04X", (int)i16));
             iSize = i16 << 16;
             /* Reading large objects involves major uglyness. Instead of getting 
              * one size, as implied by "Encyclopedia of Graphics File Formats",
@@ -1217,7 +1217,7 @@ import_data (const gchar *filename, Diag
              */
             iSize = 0;
             bRet = (1 == fread(&i16, sizeof(guint16), 1, f));
-            DIAG_NOTE(g_print("Large Object: %d\n", (int)i16));
+            DIAG_NOTE(g_printerr("Large Object: %d\n", (int)i16));
             iSize += i16;
 #if 1
             /* Ignore this large objec part */
--- dia-0.97.2.orig/plug-ins/postscript/diapsft2renderer.c
+++ dia-0.97.2/plug-ins/postscript/diapsft2renderer.c
@@ -234,7 +234,7 @@ void postscript_draw_contour(DiaPsRender
     }
 
     /*
-      printf("Got face %s (PS %s) for font %s (diafont %s)\n",
+      fprintf(stderr, "Got face %s (PS %s) for font %s (diafont %s)\n",
       ft_face->family_name,
       FT_Get_Postscript_Name(ft_face),
       pango_font_description_to_string(pango_font_describe(font)),
@@ -257,7 +257,7 @@ void postscript_draw_contour(DiaPsRender
       line_start_pos_x += 1.0 * geometry.width * scale;
 
       /*
-	printf("Drawing glyph %d: index %d at %f, %f (w %d)\n", glyph_idx, 
+	fprintf(stderr, "Drawing glyph %d: index %d at %f, %f (w %d)\n", glyph_idx, 
 	glyphs->glyphs[glyph_idx].glyph, pos_x, pos_y,
 	geometry.width);
       */	  
--- dia-0.97.2.orig/plug-ins/postscript/win32print.c
+++ dia-0.97.2/plug-ins/postscript/win32print.c
@@ -52,7 +52,7 @@ PrintError (const char* s, DWORD err)
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                    (char*)&lpBuffer,
                    0,NULL);
-    g_print ("%s : %s", s, lpBuffer);
+    g_printerr ("%s : %s", s, lpBuffer);
 		LocalFree (lpBuffer);
   }
 }
@@ -86,7 +86,7 @@ win32_printer_open (char* sName)
                     &hPrinter,
                     NULL))
   {
-    g_print ("Failed to open printer : %s\n", sName);
+    g_printerr ("Failed to open printer : %s\n", sName);
     return NULL;
   }
 
--- dia-0.97.2.orig/plug-ins/dxf/dxf-import.c
+++ dia-0.97.2/plug-ins/dxf/dxf-import.c
@@ -196,7 +196,7 @@ read_entity_line_dxf(FILE *filedxf, DxfD
             break;
         case 39: 
             line_width = g_ascii_strtod(data->value, NULL) * WIDTH_SCALE;
-	   /*printf( "line width %f\n", line_width ); */
+	   /*fprintf(stderr,  "line width %f\n", line_width ); */
             break;
 	case 62 :
             color = pal_get_rgb (atoi(data->value));
@@ -275,7 +275,7 @@ read_entity_solid_dxf(FILE *filedxf, Dxf
     Layer *layer = dia->active_layer;
    RGB_t color;
    
-/*   printf( "Solid " ); */
+/*   fprintf(stderr,  "Solid " ); */
 
     do {
         if(read_dxf_codes(filedxf, data) == FALSE){
@@ -287,43 +287,43 @@ read_entity_solid_dxf(FILE *filedxf, Dxf
 	   break;		
         case  8: 
 	   layer = layer_find_by_name(data->value, dia);
-	   /*printf( "layer: %s ", data->value );*/
+	   /*fprintf(stderr,  "layer: %s ", data->value );*/
 	   break;
         case 10:
 	   p[0].x = g_ascii_strtod(data->value, NULL) * coord_scale * measure_scale;
-	   /*printf( "P0.x: %f ", p[0].x );*/
+	   /*fprintf(stderr,  "P0.x: %f ", p[0].x );*/
 	   break;
         case 11: 
             p[1].x = g_ascii_strtod(data->value, NULL) * coord_scale * measure_scale;
-	   /*printf( "P1.x: %f ", p[1].x );*/
+	   /*fprintf(stderr,  "P1.x: %f ", p[1].x );*/
             break;
         case 12: 
             p[2].x = g_ascii_strtod(data->value, NULL) * coord_scale * measure_scale;
-	   /*printf( "P2.x: %f ", p[2].x );*/
+	   /*fprintf(stderr,  "P2.x: %f ", p[2].x );*/
             break;
         case 13: 
             p[3].x = g_ascii_strtod(data->value, NULL) * coord_scale * measure_scale;
-	   /*printf( "P3.x: %f ", p[3].x );*/
+	   /*fprintf(stderr,  "P3.x: %f ", p[3].x );*/
             break;
         case 20: 
             p[0].y = (-1)*g_ascii_strtod(data->value, NULL) * coord_scale * measure_scale;
-	   /*printf( "P0.y: %f ", p[0].y );*/
+	   /*fprintf(stderr,  "P0.y: %f ", p[0].y );*/
             break;
         case 21: 
             p[1].y = (-1)*g_ascii_strtod(data->value, NULL) * coord_scale * measure_scale;
-	   /*printf( "P1.y: %f ", p[1].y );*/
+	   /*fprintf(stderr,  "P1.y: %f ", p[1].y );*/
             break;
         case 22: 
             p[2].y = (-1)*g_ascii_strtod(data->value, NULL) * coord_scale * measure_scale;
-	   /*printf( "P2.y: %f ", p[2].y );*/
+	   /*fprintf(stderr,  "P2.y: %f ", p[2].y );*/
             break;
         case 23: 
             p[3].y = (-1)*g_ascii_strtod(data->value, NULL) * coord_scale * measure_scale;
-	   /*printf( "P3.y: %f\n", p[3].y );*/
+	   /*fprintf(stderr,  "P3.y: %f\n", p[3].y );*/
             break;
         case 39: 
             line_width = g_ascii_strtod(data->value, NULL) * WIDTH_SCALE;
-	   /*printf( "width %f\n", line_width );*/
+	   /*fprintf(stderr,  "width %f\n", line_width );*/
             break;
         case 62: 
             color = pal_get_rgb (atoi(data->value));
@@ -442,7 +442,7 @@ read_entity_polyline_dxf(FILE *filedxf,
 		
                     p = g_realloc( p, sizeof( Point ) * points );
 		
-                        /*printf( "Vertex %d\n", points );*/
+                        /*fprintf(stderr,  "Vertex %d\n", points );*/
 		  
                 }
 		break;	   
@@ -451,13 +451,13 @@ read_entity_polyline_dxf(FILE *filedxf,
                 break;		
             case  8: 
                 layer = layer_find_by_name(data->value, dia);
-                    /*printf( "layer: %s ", data->value );*/
+                    /*fprintf(stderr,  "layer: %s ", data->value );*/
                 break;
             case 10:
                 if( points != 0 )
                 {
                     p[points-1].x = g_ascii_strtod(data->value, NULL) * coord_scale * measure_scale;
-                        /*printf( "P[%d].x: %f ", points-1, p[points-1].x );*/
+                        /*fprintf(stderr,  "P[%d].x: %f ", points-1, p[points-1].x );*/
 		    bulge_x_avail = (bulge_end == points);
                 }
                 break;
@@ -465,13 +465,13 @@ read_entity_polyline_dxf(FILE *filedxf,
                 if( points != 0 )
                 {
                     p[points-1].y = (-1)*g_ascii_strtod(data->value, NULL) * coord_scale * measure_scale;
-                        /*printf( "P[%d].y: %f\n", points-1, p[points-1].y );*/
+                        /*fprintf(stderr,  "P[%d].y: %f\n", points-1, p[points-1].y );*/
 		    bulge_y_avail = (bulge_end == points);
                 }
                 break;
             case 39: 
                 line_width = g_ascii_strtod(data->value, NULL) * WIDTH_SCALE;
-                    /*printf( "width %f\n", line_width );*/
+                    /*fprintf(stderr,  "width %f\n", line_width );*/
                 break;
 	    case 40: /* default starting width */
 	    case 41: /* default ending width */
@@ -492,7 +492,7 @@ read_entity_polyline_dxf(FILE *filedxf,
                 break;
             case 70:
                 closed = 1 & atoi( data->value );
-                    /*printf( "closed %d %s", closed, data->value );*/
+                    /*fprintf(stderr,  "closed %d %s", closed, data->value );*/
                 break;
         }
 	if (points == bulge_end && bulge_x_avail && bulge_y_avail) {
@@ -549,16 +549,16 @@ read_entity_polyline_dxf(FILE *filedxf,
                     start_angle = atan( center.y - start.y /center.x - start.x );
                 }
 	   
-                    /*printf( "start x %f end x %f center x %f\n", start.x, end.x, center.x );
-                      printf( "start y %f end y %f center y %f\n", start.y, end.y, center.y );
-                      printf( "bulge %s %f startx_angle %f\n", data->value, radius, start_angle );*/
+                    /*fprintf(stderr,  "start x %f end x %f center x %f\n", start.x, end.x, center.x );
+                      fprintf(stderr,  "start y %f end y %f center y %f\n", start.y, end.y, center.y );
+                      fprintf(stderr,  "bulge %s %f startx_angle %f\n", data->value, radius, start_angle );*/
 	   
                 for( i=(points-1); i<(points+9); i++ )
                 {
                     p[i].x = center.x + cos( start_angle ) * radius;
                     p[i].y = center.y + sin( start_angle ) * radius;
                     start_angle += (-M_PI/10.0 * bulge);
-                        /*printf( "i %d x %f y %f\n", i, p[i].x, p[i].y );*/
+                        /*fprintf(stderr,  "i %d x %f y %f\n", i, p[i].x, p[i].y );*/
                 }
                 points += 10;
 	   
@@ -569,7 +569,7 @@ read_entity_polyline_dxf(FILE *filedxf,
    
     if( points == 0 )
     {
-        printf( "No vertexes defined\n" );
+        fprintf(stderr,  "No vertexes defined\n" );
         return( NULL );
     }
    
@@ -760,18 +760,18 @@ DiaObject *read_entity_arc_dxf(FILE *fil
         }
     } while(data->code != 0);
 
-    /* printf("c.x=%f c.y=%f s",center.x,center.y); */
+    /* fprintf(stderr, "c.x=%f c.y=%f s",center.x,center.y); */
     start.x = center.x + cos(start_angle) * radius; 
     start.y = center.y - sin(start_angle) * radius;
     end.x = center.x + cos(end_angle) * radius;
     end.y = center.y - sin(end_angle) * radius;
-    /*printf("s.x=%f s.y=%f e.x=%f e.y=%f\n",start.x,start.y,end.x,end.y);*/
+    /*fprintf(stderr, "s.x=%f s.y=%f e.x=%f e.y=%f\n",start.x,start.y,end.x,end.y);*/
 
 
     if (end_angle < start_angle) end_angle += 2.0*M_PI;
     curve_distance = radius * (1 - cos ((end_angle - start_angle)/2));
 
-    /*printf("start_angle: %f end_angle: %f radius:%f  curve_distance:%f\n",
+    /*fprintf(stderr, "start_angle: %f end_angle: %f radius:%f  curve_distance:%f\n",
       start_angle,end_angle,radius,curve_distance);*/
    
     arc_obj = otype->ops->create(&center, otype->default_user_data,
@@ -931,30 +931,30 @@ read_entity_text_dxf(FILE *filedxf, DxfD
 	     }
 	   while( *(++textp) != '\0' );
 		
-	   /*printf( "Found text: %s\n", textvalue );*/
+	   /*fprintf(stderr,  "Found text: %s\n", textvalue );*/
             break;
         case  8: layer = layer_find_by_name(data->value, dia);
             break;
         case 10: 
             location.x = g_ascii_strtod(data->value, NULL) * coord_scale * measure_scale;
-	   /*printf( "Found text location x: %f\n", location.x );*/
+	   /*fprintf(stderr,  "Found text location x: %f\n", location.x );*/
             break;
         case 11:
             location.x = g_ascii_strtod(data->value, NULL) * coord_scale * measure_scale;
-	   /*printf( "Found text location x: %f\n", location.x );*/
+	   /*fprintf(stderr,  "Found text location x: %f\n", location.x );*/
             break;
         case 20:
             location.y = (-1)*g_ascii_strtod(data->value, NULL) * coord_scale * measure_scale;
-	   /*printf( "Found text location y: %f\n", location.y );*/
+	   /*fprintf(stderr,  "Found text location y: %f\n", location.y );*/
             break;
         case 21:
             location.y = (-1)*g_ascii_strtod(data->value, NULL) * coord_scale * measure_scale;
 	   /*location.y = (-1)*g_ascii_strtod(data->value, NULL) / text_scale;*/
-	   /*printf( "Found text location y: %f\n", location.y );*/
+	   /*fprintf(stderr,  "Found text location y: %f\n", location.y );*/
             break;
         case 40: 
             height = g_ascii_strtod(data->value, NULL) * text_scale * coord_scale * measure_scale;
-	   /*printf( "text height %f\n", height );*/
+	   /*fprintf(stderr,  "text height %f\n", height );*/
             break;
 	 case 62: 
 	   color = pal_get_rgb (atoi(data->value));
@@ -1088,7 +1088,7 @@ void read_entity_measurement_dxf(FILE *f
 	  measure_scale = 2.54;
 	else
 	  measure_scale = 1.0;
-	/*printf( "Measure Scale: %f\n", measure_scale );*/
+	/*fprintf(stderr,  "Measure Scale: %f\n", measure_scale );*/
 	break;
       
       default:
@@ -1108,7 +1108,7 @@ read_entity_textsize_dxf(FILE *filedxf,
      {
       case 40:
 	text_scale = g_ascii_strtod(data->value, NULL);
-	/*printf( "Text Size: %f\n", text_scale );*/
+	/*fprintf(stderr,  "Text Size: %f\n", text_scale );*/
 	break;		
       default:
 	break;
@@ -1241,7 +1241,7 @@ read_section_blocks_dxf(FILE *filedxf, D
         } else if((data->code == 0) && (strcmp(data->value, "ARC") == 0)) {
             obj = read_entity_arc_dxf(filedxf,data,dia);
         } else if((data->code == 0) && (strcmp(data->value, "BLOCK") == 0)) {
-                /* printf("Begin group\n" ); */
+                /* fprintf(stderr, "Begin group\n" ); */
 	 
             group = TRUE;
             group_items = 0;
@@ -1260,7 +1260,7 @@ read_section_blocks_dxf(FILE *filedxf, D
             } while(data->code != 0);
 	
         } else if((data->code == 0) && (strcmp(data->value, "ENDBLK") == 0)) {
-                /* printf( "End group %d\n", group_items ); */
+                /* fprintf(stderr,  "End group %d\n", group_items ); */
 
             if( group && group_items > 0 && group_list != NULL )
             {
@@ -1335,31 +1335,31 @@ import_dxf(const gchar *filename, Diagra
                 } else if(strcmp(data->value, "EOF") == 0) {
 		  /* handled below */
 		} else {
-		  g_print ("DXF 0:%s not handled\n", data->value);
+		  g_printerr ("DXF 0:%s not handled\n", data->value);
 		}
             } else if(data->code == 2) {
                 if(strcmp(data->value, "ENTITIES") == 0) {
-		   /*printf( "reading section entities\n" );*/
+		   /*fprintf(stderr,  "reading section entities\n" );*/
                     read_section_entities_dxf(filedxf, data, dia);
                 }
                 else if(strcmp(data->value, "BLOCKS") == 0) {
-		   /*printf( "reading section BLOCKS\n" );*/
+		   /*fprintf(stderr,  "reading section BLOCKS\n" );*/
                     read_section_blocks_dxf(filedxf, data, dia);
                 }
                 else if(strcmp(data->value, "CLASSES") == 0) {
-		   /*printf( "reading section CLASSES\n" );*/
+		   /*fprintf(stderr,  "reading section CLASSES\n" );*/
                     read_section_classes_dxf(filedxf, data, dia);
                 }
                 else if(strcmp(data->value, "HEADER") == 0) {
-		   /*printf( "reading section HEADER\n" );*/
+		   /*fprintf(stderr,  "reading section HEADER\n" );*/
                     read_section_header_dxf(filedxf, data, dia);
                 }
                 else if(strcmp(data->value, "TABLES") == 0) {
-		  /*printf( "reading section tables\n" );*/
+		  /*fprintf(stderr,  "reading section tables\n" );*/
                     read_section_tables_dxf(filedxf, data, dia);
                 }
 	        else if(strcmp(data->value, "OBJECTS") == 0) {
-		  /*printf( "reading section objects\n" );*/
+		  /*fprintf(stderr,  "reading section objects\n" );*/
                     read_section_entities_dxf(filedxf, data, dia);
 		}
 	    }
--- dia-0.97.2.orig/plug-ins/xfig/xfig-import.c
+++ dia-0.97.2/plug-ins/xfig/xfig-import.c
@@ -323,11 +323,11 @@ fig_fix_text(gchar *text) {
 	converted = g_convert(text, strlen(text), "UTF-8", "ISO-8859-1",
 			      NULL, NULL, &err);
 	if (err != NULL) {
-	    printf("Error converting %s: %s\n", text, err->message);
+	    fprintf(stderr, "Error converting %s: %s\n", text, err->message);
 	    return text;
 	}
 	if (!g_utf8_validate(converted, -1, NULL)) {
-	    printf("Fails to validate %s\n", converted);
+	    fprintf(stderr, "Fails to validate %s\n", converted);
 	    return text;
 	}
 	if (text != converted) g_free(text);
--- dia-0.97.2.orig/tests/test-objects.c
+++ dia-0.97.2/tests/test-objects.c
@@ -209,7 +209,7 @@ _test_movement (const DiaObjectType *typ
       /* FIXME: this shape should be simple enough to actually fix the bug */
       || strcmp (type->name, "Assorted - Heart") == 0
      )
-    g_print ("SKIPPED! ");
+    g_printerr ("SKIPPED! ");
   else
     g_assert (   fabs((bbox2.right - bbox2.left) - (bbox1.right - bbox1.left)) < EPSILON
               && fabs((bbox2.bottom - bbox2.top) - (bbox1.bottom - bbox1.top)) < EPSILON);
@@ -242,7 +242,7 @@ _test_change (const DiaObjectType *type)
       /* maybe we should do something interesting first? */
       _object_change_free(change);
     } else {
-      g_print ("'%s' - no undo?\n", o->type->name);
+      g_printerr ("'%s' - no undo?\n", o->type->name);
     }
   }
   /* finally */
@@ -315,9 +315,9 @@ main (int argc, char** argv)
   object_registry_foreach (_ot_item, "/Dia/Objects");
 
   ret = g_test_run ();
-  g_print ("%d objects.\n", num_objects);
+  g_printerr ("%d objects.\n", num_objects);
 #else
-  g_print ("GLib version does not support g_test_*()");
+  g_printerr ("GLib version does not support g_test_*()");
 #endif
   return ret;
 }
--- dia-0.97.2.orig/tests/test-boundingbox.c
+++ dia-0.97.2/tests/test-boundingbox.c
@@ -140,7 +140,7 @@ main (int argc, char** argv)
 
   ret = g_test_run ();
 #else
-  g_print ("GLib version does not support g_test_*()");
+  g_printerr ("GLib version does not support g_test_*()");
 #endif
   return ret;
 }
--- dia-0.97.2.orig/app/textedit_tool.c
+++ dia-0.97.2/app/textedit_tool.c
@@ -47,7 +47,7 @@ click_select_object(DDisplay *ddisp, Poi
   if (obj) {
     /* Selected an object. */
     GList *already;
-    /*printf("Selected object!\n");*/
+    /*fprintf(stderr, "Selected object!\n");*/
       
     already = g_list_find(diagram->data->selected, obj);
     if (already == NULL) { /* Not already selected */
--- dia-0.97.2.orig/app/diagram.c
+++ dia-0.97.2/app/diagram.c
@@ -1186,7 +1186,7 @@ void diagram_unparent_children_selected(
       (change->apply)(change, dia);
     }
     if (obj->children != NULL)
-      printf("Obj still has %d children\n",
+      fprintf(stderr, "Obj still has %d children\n",
 	     g_list_length(obj->children));
   }
   if (any_unparented) {
--- dia-0.97.2.orig/app/undo.c
+++ dia-0.97.2/app/undo.c
@@ -29,8 +29,8 @@
 #include "textedit.h"
 #include "parent.h"
 
-#if 0
-#define DEBUG_PRINTF(args) printf args
+#if 0
+#define DEBUG_PRINTF(args) { char *tmps = g_strdup_printf args ; fprintf(stderr, tmps); g_free(tmps); }
 #else
 #define DEBUG_PRINTF(args)
 #endif
--- dia-0.97.2.orig/app/modify_tool.c
+++ dia-0.97.2/app/modify_tool.c
@@ -115,7 +115,7 @@ transitive_select(DDisplay *ddisp, Point
   DiaObject *obj1;
 
   for(i = 0; i < obj->num_connections; i++) {
-    printf("%d\n", i);
+    fprintf(stderr, "%d\n", i);
     j = obj->connections[i]->connected;
     while(j != NULL && (obj1 = (DiaObject *)j->data) != NULL) {
       diagram_select(ddisp->diagram, obj1);
@@ -148,11 +148,11 @@ click_select_object(DDisplay *ddisp, Poi
   if (obj!=NULL) {
     /* Selected an object. */
     GList *already;
-    /*printf("Selected object!\n");*/
+    /*fprintf(stderr, "Selected object!\n");*/
       
     already = g_list_find(diagram->data->selected, obj);
     if (already == NULL) { /* Not already selected */
-      /*printf("Not already selected\n");*/
+      /*fprintf(stderr, "Not already selected\n");*/
 
       if (!(event->state & GDK_SHIFT_MASK)) {
 	/* Not Multi-select => remove current selection */
@@ -178,7 +178,7 @@ click_select_object(DDisplay *ddisp, Poi
 
       return obj;
     } else { /* Clicked on already selected. */
-      /*printf("Already selected\n");*/
+      /*fprintf(stderr, "Already selected\n");*/
       /* To be removed once text edit mode is stable.  By then,
        * we don't want to automatically edit selected objects.
       textedit_activate_object(ddisp, obj, clickedpoint);
@@ -352,7 +352,7 @@ modify_double_click(ModifyTool *tool, Gd
   if ( clicked_obj != NULL ) {
     object_list_properties_show(ddisp->diagram, ddisp->diagram->data->selected);
   } else { /* No object selected */
-    /*printf("didn't select object\n");*/
+    /*fprintf(stderr, "didn't select object\n");*/
     if (!(event->state & GDK_SHIFT_MASK)) {
       /* Not Multi-select => Remove all selected */
       ddisplay_do_update_menu_sensitivity(ddisp);
@@ -869,10 +869,10 @@ modify_edit_end(GtkWidget *widget, GdkEv
   const PropDescription *props = obj->ops->describe_props(obj);
   int i;
 
-  printf("Ending focus\n");
+  fprintf(stderr, "Ending focus\n");
 
   for (i = 0; props[i].name != NULL; i++) {
-    printf("Testing to remove: %s\n", props[i].name);
+    fprintf(stderr, "Testing to remove: %s\n", props[i].name);
     if (props[i].type_quark == quark) {
       GPtrArray *textprops = g_ptr_array_sized_new(1);
       TextProperty *textprop;
@@ -880,7 +880,7 @@ modify_edit_end(GtkWidget *widget, GdkEv
       GtkTextBuffer *buf;
       GtkTextIter start, end;
 
-      printf("Going to stop %d\n", i);
+      fprintf(stderr, "Going to stop %d\n", i);
       buf = gtk_text_view_get_buffer(view);
       g_ptr_array_add(textprops, prop);
       obj->ops->get_props(obj, textprops);
@@ -888,7 +888,7 @@ modify_edit_end(GtkWidget *widget, GdkEv
       if (textprop->text_data != NULL) g_free(textprop->text_data);
       gtk_text_buffer_get_bounds(buf, &start, &end);
       textprop->text_data = gtk_text_buffer_get_text(buf, &start, &end, TRUE);
-      printf("Setting text %s\n", textprop->text_data);
+      fprintf(stderr, "Setting text %s\n", textprop->text_data);
       obj->ops->set_props(obj, textprops);
       gtk_widget_destroy(widget);
     }
@@ -906,7 +906,7 @@ modify_start_text_edit(DDisplay *ddisp,
   GtkTextIter start, end;
   Rectangle text_bbox;
 
-  printf("modify_start_text_edit\n");
+  fprintf(stderr, "modify_start_text_edit\n");
   /* This might need to account for zoom factor. */
   text_calc_boundingbox(text, &text_bbox);
   ddisplay_transform_coords(ddisp,
@@ -928,7 +928,7 @@ modify_start_text_edit(DDisplay *ddisp,
   gtk_text_buffer_get_bounds(buf, &start, &end);
   gtk_text_buffer_apply_tag(buf, fonttag, &start, &end);
 
-  printf("Above lines %d below %d\n",
+  fprintf(stderr, "Above lines %d below %d\n",
 	 gtk_text_view_get_pixels_above_lines(GTK_TEXT_VIEW(view)),
 	 gtk_text_view_get_pixels_below_lines(GTK_TEXT_VIEW(view)));
 
@@ -961,7 +961,7 @@ modify_make_text_edit(DDisplay *ddisp, D
   int i;
   for (i = 0; props[i].name != NULL; i++) {
     GQuark type = g_quark_from_string(PROP_TYPE_TEXT);
-    printf("Testing %s\n", props[i].type);
+    fprintf(stderr, "Testing %s\n", props[i].type);
     if (props[i].type_quark == type) {
       GtkWidget *view = gtk_text_view_new();
       GPtrArray *textprops = g_ptr_array_sized_new(1);
@@ -977,7 +977,7 @@ modify_make_text_edit(DDisplay *ddisp, D
 
       g_ptr_array_add(textprops, prop);
 
-      printf("Found text prop %d\n", i);
+      fprintf(stderr, "Found text prop %d\n", i);
       obj->ops->get_props(obj, textprops);
       textprop = (TextProperty*)prop;
       ddisplay_transform_coords(ddisp,
@@ -991,7 +991,7 @@ modify_make_text_edit(DDisplay *ddisp, D
       ascent = ddisplay_transform_length(ddisp, 
 					 text_line_get_ascent(temp_line));
       text_line_destroy(temp_line);
-      printf("Text prop string %s pos %d, %d ascent %f\n",
+      fprintf(stderr, "Text prop string %s pos %d, %d ascent %f\n",
 	     textprop->text_data, x, y, ascent);
       ascent_pixels = ddisplay_transform_length(ddisp, ascent);
       y -= ascent_pixels;
@@ -1008,7 +1008,7 @@ modify_make_text_edit(DDisplay *ddisp, D
       gtk_text_buffer_get_bounds(buf, &start, &end);
       gtk_text_buffer_apply_tag(buf, fonttag, &start, &end);
 
-      printf("Above lines %d below %d\n",
+      fprintf(stderr, "Above lines %d below %d\n",
 	     gtk_text_view_get_pixels_above_lines(GTK_TEXT_VIEW(view)),
 	     gtk_text_view_get_pixels_below_lines(GTK_TEXT_VIEW(view)));
 
--- dia-0.97.2.orig/app/load_save.c
+++ dia-0.97.2/app/load_save.c
@@ -1117,7 +1117,7 @@ diagram_cleanup_autosave(Diagram *dia)
   savefile = dia->autosavefilename;
   if (savefile == NULL) return;
 #ifdef TRACES
-  g_print("Cleaning up autosave %s for %s\n", 
+  g_printerr("Cleaning up autosave %s for %s\n", 
           savefile, dia->filename ? dia->filename : "<no name>");
 #endif
   if (g_stat(savefile, &statbuf) == 0) { /* Success */
--- dia-0.97.2.orig/app/display.c
+++ dia-0.97.2/app/display.c
@@ -644,7 +644,7 @@ ddisplay_render_pixmap(DDisplay *ddisp,
 #endif
   
   if (ddisp->renderer==NULL) {
-    printf("ERROR! Renderer was NULL!!\n");
+    fprintf(stderr, "ERROR! Renderer was NULL!!\n");
     return;
   }
 
@@ -669,7 +669,7 @@ ddisplay_render_pixmap(DDisplay *ddisp,
   data_render(ddisp->diagram->data, ddisp->renderer, update,
 	      ddisplay_obj_render, (gpointer) ddisp);
 #ifdef TRACES
-  g_print ("data_render(%g%%) took %g seconds\n", ddisp->zoom_factor * 5.0, g_timer_elapsed (timer, NULL));
+  g_printerr ("data_render(%g%%) took %g seconds\n", ddisp->zoom_factor * 5.0, g_timer_elapsed (timer, NULL));
   g_timer_destroy (timer);
 #endif
   /* Draw handles for all selected objects */
--- dia-0.97.2.orig/app/gtkvwrapbox.c
+++ dia-0.97.2/app/gtkvwrapbox.c
@@ -221,7 +221,7 @@ gtk_vwrap_box_size_request (GtkWidget
           requisition->width = layout_width;
         }
 
-      /* g_print ("ratio for height %d width %d = %f\n",
+      /* g_printerr ("ratio for height %d width %d = %f\n",
          (gint) layout_height,
          (gint) layout_width,
          ratio);
@@ -231,7 +231,7 @@ gtk_vwrap_box_size_request (GtkWidget
 
   requisition->width += GTK_CONTAINER (wbox)->border_width * 2; /*<h2v-skip>*/
   requisition->height += GTK_CONTAINER (wbox)->border_width * 2; /*<h2v-skip>*/
-  /* g_print ("chosen: height %d, width %d\n",
+  /* g_printerr ("chosen: height %d, width %d\n",
      requisition->height,
      requisition->width);
   */
@@ -419,10 +419,10 @@ layout_col (GtkWrapBox    *wbox,
             }
           else
             {
-              /* g_print ("child_allocation.y %d += %d * %f ",
+              /* g_printerr ("child_allocation.y %d += %d * %f ",
                        child_allocation.y, n_children, extra); */
               child_allocation.y += n_children * extra;
-              /* g_print ("= %d\n",
+              /* g_printerr ("= %d\n",
                        child_allocation.y); */
               child_allocation.height = MIN (child_requisition.height,
                                             area->height - child_allocation.y + area->y);
@@ -606,7 +606,7 @@ gtk_vwrap_box_size_allocate (GtkWidget
   area.width = MAX (1, (gint) allocation->width - border * 2);
 
   /*<h2v-off>*/
-  /* g_print ("got: width %d, height %d\n",
+  /* g_printerr ("got: width %d, height %d\n",
      allocation->width,
      allocation->height);
   */
--- dia-0.97.2.orig/app/autosave.c
+++ dia-0.97.2/app/autosave.c
@@ -119,7 +119,7 @@ autosave_restore_documents(void)
 
   if (dir == NULL) return;
   while ((ent = g_dir_read_name(dir)) != NULL) {
-    printf("Found autosave file %s\n", ent);
+    fprintf(stderr, "Found autosave file %s\n", ent);
     files = g_list_prepend(files, g_strdup(ent));
   }
 
--- dia-0.97.2.orig/app/app_procs.c
+++ dia-0.97.2/app/app_procs.c
@@ -210,7 +210,7 @@ show_layers_parse_numbers(DiagramData *d
 
   if ( high <= low ) {
     /* This is not an errror */
-    g_print(_("Warning: invalid layer range %lu - %lu\n"), low, high-1 );
+    g_printerr(_("Warning: invalid layer range %lu - %lu\n"), low, high-1 );
     return;
   }
   if (high > n_layers)
@@ -222,7 +222,7 @@ show_layers_parse_numbers(DiagramData *d
       Layer *lay = (Layer *)g_ptr_array_index(diagdata->layers, i);
 
       if (visible_layers[i] == TRUE)
-	g_print(_("Warning: Layer %lu (%s) selected more than once.\n"), i, lay->name);
+	g_printerr(_("Warning: Layer %lu (%s) selected more than once.\n"), i, lay->name);
       visible_layers[i] = TRUE;
     }
 }
@@ -248,7 +248,7 @@ show_layers_parse_word(DiagramData *diag
 	      && ((p[len] == 0) || (p[len] == ','))){
 	    found = TRUE;
 	    if (visible_layers[k] == TRUE)
-	      g_print(_("Warning: Layer %d (%s) selected more than once.\n"), k, lay->name);
+	      g_printerr(_("Warning: Layer %d (%s) selected more than once.\n"), k, lay->name);
 	    visible_layers[k] = TRUE;
 	  }
 	}
@@ -257,7 +257,7 @@ show_layers_parse_word(DiagramData *diag
   }
 
   if (found == FALSE)
-    g_print(_("Warning: There is no layer named %s\n"), str);
+    g_printerr(_("Warning: There is no layer named %s\n"), str);
 }
 
 static void
@@ -383,7 +383,7 @@ do_convert(const char *infname,
   }
   else
     ef->export_func(diagdata, outfname, infname, ef->user_data);
-  /* if (!quiet) */ fprintf(stdout,
+  /* if (!quiet) */ fprintf(stderr,
                       _("%s --> %s\n"),
                         infname,outfname);
   g_object_unref(diagdata);
@@ -504,7 +504,7 @@ dump_dependencies(void)
     if ((len = readlink (PREFIX "/lib/libpango-1.0.so", linkedname, 1023)) > 0) {
       /* man 2 readlink : does not append a  NUL  character */
       linkedname[len] = '\0';
-      g_print ("%s/%s\n", PREFIX, linkedname);
+      g_printerr ("%s/%s\n", PREFIX, linkedname);
     }
   }
 #endif
@@ -778,10 +778,10 @@ app_init (int argc, char **argv)
 
     if (!g_option_context_parse (context, &argc, &argv, &error)) {
       if (error) { /* IMO !error here is a bug upstream, triggered e.g. with --gdk-debug=updates */
-	g_print ("%s", error->message);
+	g_printerr ("%s", error->message);
 	g_error_free (error);
       } else {
-	g_print (_("Invalid option?"));
+	g_printerr (_("Invalid option?"));
       }
 
       g_option_context_free(context);
@@ -804,7 +804,7 @@ app_init (int argc, char **argv)
 	  filename = g_filename_to_utf8 (filenames[i], -1, NULL, NULL, NULL);
 
 	if (!filename) {
-	  g_print (_("Filename conversion failed: %s\n"), filenames[i]);
+	  g_printerr (_("Filename conversion failed: %s\n"), filenames[i]);
 	  continue;
 	}
 
@@ -817,7 +817,7 @@ app_init (int argc, char **argv)
 	if (g_file_test (testpath, G_FILE_TEST_IS_REGULAR))
 	  files = g_slist_append(files, filename);
 	else {
-	  g_print (_("Missing input: %s\n"), filename);
+	  g_printerr (_("Missing input: %s\n"), filename);
 	  g_free (filename);
 	}
 	if (filename != testpath)
@@ -882,9 +882,9 @@ app_init (int argc, char **argv)
   if (version) {
 #if (defined __TIME__) && (defined __DATE__)
     /* TRANSLATOR: 2nd and 3rd %s are time and date respectively. */
-    printf(g_locale_from_utf8(_("Dia version %s, compiled %s %s\n"), -1, NULL, NULL, NULL), VERSION, __TIME__, __DATE__);
+    fprintf(stderr, g_locale_from_utf8(_("Dia version %s, compiled %s %s\n"), -1, NULL, NULL, NULL), VERSION, __TIME__, __DATE__);
 #else
-    printf(g_locale_from_utf8(_("Dia version %s\n"), -1, NULL, NULL, NULL), VERSION);
+    fprintf(stderr, g_locale_from_utf8(_("Dia version %s\n"), -1, NULL, NULL, NULL), VERSION);
 #endif
     if (verbose)
       dump_dependencies();
--- dia-0.97.2.orig/app/gtkhwrapbox.c
+++ dia-0.97.2/app/gtkhwrapbox.c
@@ -221,7 +221,7 @@ gtk_hwrap_box_size_request (GtkWidget
           requisition->height = layout_height;
         }
 
-      /* g_print ("ratio for width %d height %d = %f\n",
+      /* g_printerr ("ratio for width %d height %d = %f\n",
          (gint) layout_width,
          (gint) layout_height,
          ratio);
@@ -231,7 +231,7 @@ gtk_hwrap_box_size_request (GtkWidget
 
   requisition->width += GTK_CONTAINER (wbox)->border_width * 2; /*<h2v-skip>*/
   requisition->height += GTK_CONTAINER (wbox)->border_width * 2; /*<h2v-skip>*/
-  /* g_print ("chosen: width %d, height %d\n",
+  /* g_printerr ("chosen: width %d, height %d\n",
      requisition->width,
      requisition->height);
   */
@@ -419,10 +419,10 @@ layout_row (GtkWrapBox    *wbox,
             }
           else
             {
-              /* g_print ("child_allocation.x %d += %d * %f ",
+              /* g_printerr ("child_allocation.x %d += %d * %f ",
                        child_allocation.x, n_children, extra); */
               child_allocation.x += n_children * extra;
-              /* g_print ("= %d\n",
+              /* g_printerr ("= %d\n",
                        child_allocation.x); */
               child_allocation.width = MIN (child_requisition.width,
                                             area->width - child_allocation.x + area->x);
@@ -606,7 +606,7 @@ gtk_hwrap_box_size_allocate (GtkWidget
   area.height = MAX (1, (gint) allocation->height - border * 2);
 
   /*<h2v-off>*/
-  /* g_print ("got: width %d, height %d\n",
+  /* g_printerr ("got: width %d, height %d\n",
      allocation->width,
      allocation->height);
   */
--- dia-0.97.2.orig/app/layer_dialog.c
+++ dia-0.97.2/app/layer_dialog.c
@@ -247,10 +247,10 @@ layer_list_events (GtkWidget *widget,
       kevent = (GdkEventKey *) event;
       switch (kevent->keyval) {
       case GDK_Up:
-	/* printf ("up arrow\n"); */
+	/* fprintf(stderr, "up arrow\n"); */
 	break;
       case GDK_Down:
-	/* printf ("down arrow\n"); */
+	/* fprintf(stderr, "down arrow\n"); */
 	break;
       default:
 	return FALSE;
@@ -1416,7 +1416,7 @@ layer_visibility_change_revert(struct La
   }
 
   if (vis != NULL || i < layers->len) {
-    printf("Internal error: visibility undo has %d visibilities, but %d layers\n",
+    fprintf(stderr, "Internal error: visibility undo has %d visibilities, but %d layers\n",
 	   g_list_length(change->original_visibility), layers->len);
   }
 
--- dia-0.97.2.orig/app/disp_callbacks.c
+++ dia-0.97.2/app/disp_callbacks.c
@@ -358,7 +358,7 @@ ddisplay_size_allocate (GtkWidget *widge
   g_return_if_fail (data != NULL);
 
 #if 0
-  g_print ("ddisp::size_allocate: %d,%d -> %d,%d\n", allocation->width, allocation->height,
+  g_printerr ("ddisp::size_allocate: %d,%d -> %d,%d\n", allocation->width, allocation->height,
 	   widget->allocation.width, widget->allocation.height);
 #endif
   widget->allocation = *allocation;
@@ -788,7 +788,7 @@ ddisplay_canvas_events (GtkWidget *canva
         key_handled = FALSE;
         im_context_used = FALSE;
 #if 0
-	printf("Key input %d in state %d\n", kevent->keyval, textedit_mode(ddisp));
+	fprintf(stderr, "Key input %d in state %d\n", kevent->keyval, textedit_mode(ddisp));
 #endif
         focus = get_active_focus((DiagramData *) ddisp->diagram);
         if (focus != NULL) {
--- dia-0.97.2.orig/objects/standard/arc.c
+++ dia-0.97.2/objects/standard/arc.c
@@ -335,17 +335,17 @@ arc_move_handle(Arc *arc, Handle *handle
   }
 
   if (handle->id == HANDLE_MIDDLE) {
-          TRACE(printf("curve_dist: %.2f \n",arc->curve_distance));
+          TRACE(fprintf(stderr, "curve_dist: %.2f \n",arc->curve_distance));
           arc->curve_distance = arc_compute_curve_distance(arc, &arc->connection.endpoints[0], &arc->connection.endpoints[1], to);
-          TRACE(printf("curve_dist: %.2f \n",arc->curve_distance));
+          TRACE(fprintf(stderr, "curve_dist: %.2f \n",arc->curve_distance));
 
   } else {
         Point best;
-        TRACE(printf("Modifiers: %d \n",modifiers));
+        TRACE(fprintf(stderr, "Modifiers: %d \n",modifiers));
         if (modifiers & MODIFIER_SHIFT)
         /* if(arc->end_arrow.type == ARROW_NONE)*/
         {
-          TRACE(printf("SHIFT USED, to at %.2f %.2f  ",to->x,to->y));
+          TRACE(fprintf(stderr, "SHIFT USED, to at %.2f %.2f  ",to->x,to->y));
           if (arc_find_radial(arc, to, &best)){
             /* needs to move two handles at the same time 
              * compute pos of middle handle */
@@ -360,10 +360,10 @@ arc_move_handle(Arc *arc, Handle *handle
             connection_move_handle(&arc->connection, handle->id, &best, cp, reason, modifiers);
             /* recompute curve distance equiv. move middle handle */
             arc->curve_distance = arc_compute_curve_distance(arc, &arc->connection.endpoints[0], &arc->connection.endpoints[1], &midpoint);
-            TRACE(printf("curve_dist: %.2f \n",arc->curve_distance));
+            TRACE(fprintf(stderr, "curve_dist: %.2f \n",arc->curve_distance));
           }
           else {
-            TRACE(printf("NO best\n"));
+            TRACE(fprintf(stderr, "NO best\n"));
           }
        } else {
           connection_move_handle(&arc->connection, handle->id, to, cp, reason, modifiers);
@@ -411,21 +411,21 @@ arc_compute_midpoint(Arc *arc, const Poi
                     return 0;
             }
             if (angle < -1 * M_PI){
-                    TRACE(printf("angle: %.2f ",angle));
+                    TRACE(fprintf(stderr, "angle: %.2f ",angle));
                     angle += 2*M_PI;
-                    TRACE(printf("angle: %.2f ",angle));
+                    TRACE(fprintf(stderr, "angle: %.2f ",angle));
             }
             if (angle > 1 * M_PI){
-                    TRACE(printf("angle: %.2f ",angle));
+                    TRACE(fprintf(stderr, "angle: %.2f ",angle));
                     angle -= 2*M_PI;
-                    TRACE(printf("angle: %.2f ",angle));
+                    TRACE(fprintf(stderr, "angle: %.2f ",angle));
             }
 
             midpos = arc->middle_handle.pos;
             /*rotate middle handle by half the angle */
-            TRACE(printf("\nmidpos before: %.2f %.2f \n",midpos.x, midpos.y));
+            TRACE(fprintf(stderr, "\nmidpos before: %.2f %.2f \n",midpos.x, midpos.y));
             rotate_point_around_point(&midpos, &arc->center, angle/2); 
-            TRACE(printf("\nmidpos after : %.2f %.2f \n",midpos.x, midpos.y));
+            TRACE(fprintf(stderr, "\nmidpos after : %.2f %.2f \n",midpos.x, midpos.y));
             *midpoint = midpos;
             return 1;
 }
@@ -481,12 +481,12 @@ calculate_arc_object_edge(Arc *arc, real
   mid2 = get_middle_arc_angle(ang_start, ang_end, clockwiseness);
   mid3 = ang_end;
 
-  TRACE(printf("Find middle angle between %f and  %f\n",ang_start,ang_end));
+  TRACE(fprintf(stderr, "Find middle angle between %f and  %f\n",ang_start,ang_end));
   /* If the other end is inside the object */
   arc_get_point_at_angle(arc,target,mid1);
   dist = obj->ops->distance_from(obj, target );
   if (dist < 0.001){
-          TRACE(printf("Point at %f: %f,%f is very close to object: %f, returning it\n",mid1, target->x, target->y, dist)); 
+          TRACE(fprintf(stderr, "Point at %f: %f,%f is very close to object: %f, returning it\n",mid1, target->x, target->y, dist)); 
           return ;
   }
   do {
@@ -510,7 +510,7 @@ calculate_arc_object_edge(Arc *arc, real
 #ifdef TRACE_DIST
     for (j = 0; j < i; j++) {
       arc_get_point_at_angle(arc,target,trace[j]);
-      printf("%d: %f  : %f,%f :%f\n", j, trace[j],target->x,target->y, disttrace[j]);
+      fprintf(stderr, "%d: %f  : %f,%f :%f\n", j, trace[j],target->x,target->y, disttrace[j]);
     }
 #endif
   arc_get_point_at_angle(arc,target,mid2);
@@ -534,17 +534,17 @@ arc_draw(Arc *arc, DiaRenderer *renderer
   start_cp = arc->connection.endpoint_handles[0].connected_to;
   end_cp = arc->connection.endpoint_handles[1].connected_to;
 
-  TRACE(printf("drawing arc:\n start:%f :%f,%f \tend:%f :%f,%f\n",arc->angle1,endpoints[0].x,endpoints[0].y, arc->angle2,endpoints[1].x,endpoints[1].y));
+  TRACE(fprintf(stderr, "drawing arc:\n start:%f :%f,%f \tend:%f :%f,%f\n",arc->angle1,endpoints[0].x,endpoints[0].y, arc->angle2,endpoints[1].x,endpoints[1].y));
 
   if (connpoint_is_autogap(start_cp)) {
-     TRACE(printf("computing start intersection\ncurve_distance: %f\n",arc->curve_distance));
+     TRACE(fprintf(stderr, "computing start intersection\ncurve_distance: %f\n",arc->curve_distance));
      if (arc->curve_distance < 0)
              calculate_arc_object_edge(arc, arc->angle1, arc->angle2, start_cp->object, &gaptmp[0], FALSE);
      else
              calculate_arc_object_edge(arc, arc->angle2, arc->angle1, start_cp->object, &gaptmp[0], TRUE);
   }
   if (connpoint_is_autogap(end_cp)) {
-     TRACE(printf("computing end intersection\ncurve_distance: %f\n",arc->curve_distance));
+     TRACE(fprintf(stderr, "computing end intersection\ncurve_distance: %f\n",arc->curve_distance));
      if (arc->curve_distance < 0)
              calculate_arc_object_edge(arc, arc->angle2, arc->angle1, end_cp->object, &gaptmp[1], TRUE);
      else
@@ -561,7 +561,7 @@ arc_draw(Arc *arc, DiaRenderer *renderer
   
   /* Special case when almost line: */
   if (fabs(arc->curve_distance) <= 0.01) {
-          TRACE(printf("drawing like a line\n")); 
+          TRACE(fprintf(stderr, "drawing like a line\n")); 
     renderer_ops->draw_line_with_arrows(renderer,
 					 &gaptmp[0], &gaptmp[1],
 					 arc->line_width,
--- dia-0.97.2.orig/objects/chronogram/chronoline_event.c
+++ dia-0.97.2/objects/chronogram/chronoline_event.c
@@ -74,7 +74,7 @@ static void dump_parsed_clelist(CLEventL
   int i = 0;
   const char *s = NULL;
 
-  printf("ChronoLine Event List dump follows:\n");
+  fprintf(stderr, "ChronoLine Event List dump follows:\n");
   while (clel) {
     CLEvent *evt = (CLEvent *)(clel->data);
     switch (evt->type) {
@@ -85,11 +85,11 @@ static void dump_parsed_clelist(CLEventL
     default:
       g_assert_not_reached();
     }
-    printf("%3d  t=%7.3f %s\n",i++,evt->time,s);
+    fprintf(stderr, "%3d  t=%7.3f %s\n",i++,evt->time,s);
     
     clel = g_slist_next(clel);
   }
-  printf("ChronoLine Event List dump finished.\n");
+  fprintf(stderr, "ChronoLine Event List dump finished.\n");
 }
 
 #endif
@@ -248,7 +248,7 @@ __chksum(const char *str, real rise, rea
     i = __forward_checksum_i(i,*p);
     p++;
   }
-  /* printf("chksum[%s] = %d\n",str,i); */
+  /* fprintf(stderr, "chksum[%s] = %d\n",str,i); */
   return i;
 }
 
--- dia-0.97.2.orig/objects/Database/table_dialog.c
+++ dia-0.97.2/objects/Database/table_dialog.c
@@ -323,7 +323,7 @@ table_change_apply (TableChange * change
   TableState * old_state;
   GList * lst;
 
-  g_print ("apply (o: 0x%08x) (c: 0x%08x)\n", GPOINTER_TO_UINT(obj), GPOINTER_TO_UINT(change));
+  g_printerr ("apply (o: 0x%08x) (c: 0x%08x)\n", GPOINTER_TO_UINT(obj), GPOINTER_TO_UINT(change));
 
   /* first the get the current state for later use */
   old_state = table_state_new (change->obj);
--- dia-0.97.2.orig/objects/custom/shape_typeinfo.c
+++ dia-0.97.2/objects/custom/shape_typeinfo.c
@@ -148,9 +148,9 @@ _error (void *ctx,
   if (READ_DONE == context->state)
     return; /* we are ready, not interested in further complains */
   va_start(args, msg);
-  g_print ("Error: %s\n", context->si->filename);
-  g_vprintf (msg, args);
-  g_print ("\n");
+  g_printerr ("Error: %s\n", context->si->filename);
+  g_vfprintf(stderr, msg, args);
+  g_printerr ("\n");
   va_end(args);
 }
 
@@ -165,9 +165,9 @@ _warning (void *ctx,
   if (READ_DONE == context->state)
     return; /* we are ready, not interested in further complains */
   va_start(args, msg);
-  g_print ("Warning: %s\n", context->si->filename);
-  g_vprintf (msg, args);
-  g_print ("\n");
+  g_printerr ("Warning: %s\n", context->si->filename);
+  g_vfprintf(stderr, msg, args);
+  g_printerr ("\n");
   va_end(args);
 }
 
@@ -215,7 +215,7 @@ shape_typeinfo_load (ShapeInfo* info)
     }
     return TRUE;
   } else {
-    g_print ("Preloading shape file '%s' failed.\n"
+    g_printerr ("Preloading shape file '%s' failed.\n"
              "Please ensure that <name/> and <icon/> are early in the file.\n",
              info->filename);
   }
--- dia-0.97.2.orig/objects/UML/class_dialog.c
+++ dia-0.97.2/objects/UML/class_dialog.c
@@ -742,7 +742,7 @@ attribute_list_item_destroy_callback(Gtk
 
   if (attr != NULL) {
     uml_attribute_destroy(attr);
-    /*printf("Destroying list_item's user_data!\n");*/
+    /*fprintf(stderr, "Destroying list_item's user_data!\n");*/
   }
 }
 
@@ -1686,7 +1686,7 @@ operations_list_item_destroy_callback(Gt
 
   if (op != NULL) {
     uml_operation_destroy(op);
-    /*printf("Destroying operation list_item's user_data!\n");*/
+    /*fprintf(stderr, "Destroying operation list_item's user_data!\n");*/
   }
 }
 
@@ -2508,7 +2508,7 @@ templates_list_item_destroy_callback(Gtk
 
   if (param != NULL) {
     uml_formalparameter_destroy(param);
-    /*printf("Destroying list_item's user_data!\n"); */
+    /*fprintf(stderr, "Destroying list_item's user_data!\n"); */
   }
 }
 
