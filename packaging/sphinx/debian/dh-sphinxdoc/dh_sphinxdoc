#!/usr/bin/perl

# Copyright Â© 2011 Jakub Wilk <jwilk@debian.org>
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# * Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in the
#   documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=head1 NAME

dh_sphinxdoc - helps with packaging Sphinx-generated documentation

=head1 SYNOPSIS

dh_sphinxdoc [S<I<debhelper options>>] [B<-X>I<item>] [I<directory>...]

=head1 DESCRIPTION

B<dh_sphinxdoc> is a debhelper program that prepares Sphinx-generated
documentation for inclusion in a Debian package. More specifically:

=over 4

=item *

It checks if all the files referenced by F<searchindex.js> exist.

=item *

It replaces known F<*.js> files with symlinks to F</usr/share/javascript/sphinxdoc/>
and generates B<${sphinxdoc:Depends}> substitution variable.

=item *

It removes the F<.doctrees> directory.

=item *

It removes the F<.buildinfo> file.

=item *

It removes the F<websupport.js> file.

=back

=head1 OPTIONS

=over 4

=item I<directory>

By default, B<dh_sphinxdoc> scans your package looking for directories looking
like they contain Sphinx-generated documentation. However, if you explicitly
provide one or more directories, only they will be processed.

=item B<-X>I<item>, B<--exclude=>I<item>

Exclude files that contain I<item> anywhere in their filename from
being symlinked, removed or checked for existence.

=back

=head1 BUGS

Symlinking translations.js and non-English searchtools.js is not supported.

=cut

use strict;
use warnings;

use Digest::MD5;
use File::Find;
use Debian::Debhelper::Dh_Lib;

my %packaged_js = ();
my @cruft_js = qw(websupport.js);

sub md5($)
{
    my ($filename) = @_;
    my $md5 = Digest::MD5->new;
    open(F, '<', $filename) or error("cannot open $filename");
    $md5->addfile(*F);
    close(F);
    return $md5->digest;
}

sub load_packaged_js()
{
    my %versions = ();
    my $root = 'debian/libjs-sphinxdoc'; # It's tempting to use
    # tmpdir('libjs-sphinxdoc') here, but it would break if the user passed
    # --tmpdir to the command.
    $root = '' unless -d $root;
    my $path = "$root/usr/share/javascript/sphinxdoc";
    open(F, '<', "$path/index") or error("cannot open $path/index");
    while (<F>)
    {
        chomp;
        next if /^(#|\s*$)/;
        my ($js, $minver) = split(/\s+/, $_, 2);
        unless (defined($minver))
        {
            $js =~ m{^([0-9.]+)/} or error("syntax error in $path/index");
            $minver = $1;
        }
        $versions{$js} = $minver;
    }
    close(F);
    find({
        wanted => sub {
            my $js = $_;
            my ($jsbase, $jsname) = m{([0-9.]+/(\w+[.]js))$} or return;
            my $version = $versions{$jsbase};
            defined($version) or error("$jsbase is not in the index; is it up-to-date?");
            delete $versions{$jsbase};
            my $md5;
            if (-l $js)
            {
                # Follow the symlink, but only if points *outside* our own directory.
                my $js_target = readlink($js);
                $js_target =~ m{^(/|\Q../../\E)} or return;
                unless ($js_target =~ m{^/})
                {
                    $js_target = "$js/../$js_target";
                    while ($js_target =~ s{[^./][^/]+/[.][.]/}{}) {};
                }
                $md5 = md5($js_target);
            }
            else
            {
                $js =~ s{^\Q$root\E}{} unless -f $js;
                $md5 = md5($js);
            }
            $js =~ s{^\Q$root\E}{};
            my $data = [$js, "libjs-sphinxdoc (>= $version)"];
            $packaged_js{$md5} = $data;
            $packaged_js{$jsname} = $data;
        },
        no_chdir => 1
    }, $path);
    map { error("$path/$_ is missing") } keys(%versions);
}

sub looks_like_sphinx_doc($)
{
    my ($path) = @_;
    return 0 unless -f "$path/searchindex.js";
    return 0 unless -f "$path/search.html";
    return 1;
}

sub sanity_check($)
{
    local $/;
    my ($path) = @_;
    my $indexfn = "$path/searchindex.js";
    open(F, '<', $indexfn) or error("cannot open $indexfn");
    my $index = <F>;
    close(F);
    $index =~ m{^Search[.]setIndex[(].*?filenames:\["(.*?)"\].*[)]$} or error("$indexfn doesn't look like a Sphinx search index");
    $index = $1;
    my $searchfn = "$path/search.html";
    open(F, '<', $searchfn) or error("cannot open $searchfn");
    my $search = <F>;
    close F;
    $search =~ s/<!--.*?-->//g; # strip comments
    my %js = ();
    grep { s/[?#].*//; $js{$_} = 1 unless m/^[a-z][a-z0-9.+-]*:/i or excludefile("$path/$_"); } $search =~ m{<script type="text/javascript" src="([^"]++)"></script>}g;
    my $loads_searchindex = $search =~ m/\QjQuery(function() { Search.loadIndex("searchindex.js"); });\E/;
    my ($has_source) = $search =~ m{HAS_SOURCE:\s*(true|false)};
    my ($url_root) = $search =~ m{URL_ROOT:\s*'([^']*)'};
    (%js and $loads_searchindex and defined $has_source and defined $url_root) or error("$searchfn doesn't look like a Sphinx search page");
    $has_source = $has_source eq 'true';
    $url_root =~ m{^([a-z]+:/)?/} and error("URL_ROOT in $searchfn is not relative");
    for my $js (keys(%js))
    {
        -f "$path/$js" or -l "$path/$js" or error("$path/$js is missing");
    }
    for my $page (split(/","/, $index))
    {
        -f "$path/$page.html"
            or excludefile("$path/$page.html")
            or error("$path/$page.html is missing");
        -f "$path/_sources/$page.txt"
            or excludefile("$path/_sources/$page.txt")
            or error("$path/_sources/$page.txt is missing")
            if $has_source;
    }
    if (opendir(D, "$path/_static/"))
    {
        grep {
            $js{"_static/$_"} = 1
                if /[.]js$/ and not excludefile("$path/_static/$_"); 
        } readdir(D);
        closedir(D);
    }
    return keys(%js);
}

sub unknown_javascript($)
{
    my ($js) = @_;
    my $message = "unknown JavaScript code: $js";
    $js =~ s{.*/}{};
    my $basic = grep { $_ eq $js } qw(searchtools.js doctools.js jquery.js underscore.js);
    my $cruft = grep { $_ eq $js } @cruft_js;
    if ($basic)
    {
        error("error: $message");
    }
    elsif (not $cruft)
    {
        warning("ignoring $message");
    }
}

sub ln_sf($$)
{
    my ($orig_target, $orig_source) = my ($target, $source) = @_;
    $source =~ s{^debian/[^/]++/+}{} or die;
    $target =~ s{^/++}{} or die;
    my @source = split(m{/++}, $source);
    my @target = split(m{/++}, $target);
    @source > 0 and @target > 0 or die;
    if ($source[0] eq $target[0])
    {
        # Make the symlink relative, as per Policy 10.5.
        while (@source > 0 and @target > 0 and $source[0] eq $target[0])
        {
            shift @source;
            shift @target;
        }
        $target = ('../' x $#source) . join('/', @target);
    }
    else
    {
        # Keep the symlink absolute, as per Policy 10.5.
        $target = $orig_target;
    }
    doit('ln', '-sf', $target, $orig_source);
}

sub fix_symlinks($@)
{
    my %deps = ();
    my ($path, @js) = @_;
    for my $js (@js)
    {
        my $id = '';
        if (-l "$path/$js")
        {
            my $symlink_target = readlink("$path/$js");
            $symlink_target =~ m{/sphinxdoc/} and next;
            $symlink_target =~ m{/javascript/\w+/(\w+)([.](min|lite|pack))?[.]js$} and $id = "$1.js";
        }
        elsif (-f "$path/$js")
        {
            $id = md5("$path/$js");
        }
        if (exists $packaged_js{$id})
        {
            my ($target, $dependency) = @{$packaged_js{$id}};
            ln_sf($target, "$path/$js");
            $deps{$dependency} = 1;
        }
        else
        {
            unknown_javascript("$path/$js");
        }
    }
    return keys %deps;
}

sub drop_cruft($)
{
    my ($path) = @_;
    my $doctrees = "$path/.doctrees";
    my $buildinfo = "$path/.buildinfo";
    if (-d $doctrees and not excludefile($doctrees))
    {
        doit('rm', '-rf', $doctrees);
    }
    if (-f $buildinfo and not excludefile($buildinfo))
    {
        doit('rm', '-f', $buildinfo);
    }
    foreach my $js (@cruft_js)
    {
        my $js = "$path/_static/$js";
        if (-f $js and not excludefile($js))
        {
            doit('rm', '-f', $js) if -f $js;
        }
    }
}
 
sub fix_sphinx_doc($$)
{
    my ($package, $path) = @_;
    return 0 if not looks_like_sphinx_doc($path);
    my @js = sanity_check($path);
    my @deps = fix_symlinks($path, @js);
    drop_cruft($path);
    map { addsubstvar($package, "sphinxdoc:Depends", $_) } @deps;
    return 1;
}

init();

load_packaged_js();

my @paths = @ARGV;
@paths = (undef) unless @paths;

foreach my $path (@paths)
{
    my $done = 0;
    foreach my $package (@{$dh{DOPACKAGES}})
    {
        my $pkgpath = tmpdir($package);
        if (defined $path)
        {
            next if -l $path;
            $pkgpath .= "/$path";
            $done += fix_sphinx_doc($package, $pkgpath);
        }
        else
        {
            $pkgpath .= '/usr/share/doc/';
            next unless -d $pkgpath;
            find({
                wanted => sub {
                    return unless -d;
                    return if -l;
                    return if excludefile($_);
                    $done += fix_sphinx_doc($package, $_);
                },
                no_chdir => 1
            }, $pkgpath);
        }
    }
    if ($done == 0)
    {
        my $message = 'Sphinx documentation not found';
        $message .= " at $path" if defined $path;
        error($message);
    }
}

=head1 SEE ALSO

L<debhelper(7)>, L<dh(1)>.

This program is meant to be used together with debhelper.

=head1 AUTHOR

Jakub Wilk <jwilk@debian.org>

=cut

# vim:ts=4 sw=4 et
